/** API routes for auth. */

const db = require("../db");
const express = require("express");
const router = new express.Router();
const ExpressError = require("../helpers/expressError");
const jwt = require("jsonwebtoken");
const { SECRET_KEY } = require("../config");
const bcrypt = require("bcrypt");
const { BCRYPT_WORK_FACTOR } = require("../config");
const jsonscema = require("jsonschema");
const userSchema = require("../schema/userSchema.json");
const process = require("process");
const User = require("../models/usersModel");
process.env.NODE_ENV = "test";

router.get("/", async function (req, res, next) {
  try {
    const users = await User.findAll();
    return res.json(users);
  } catch (err) {
    return next(err);
  }
});

router.get("/:id", async function (req, res, next) {
  console.log("ID HIT");
  try {
    // TODO: This is going to be all content generated by user
    // but not the user's info

    /*
    TODO: 
    */
    // const result = await db.query(
    //   `SELECT u.id, u.username, u.first_name, u.last_name, u.email
    //   JSON_AGG(DISTINCT p.id) AS posts,
    //   JSON_AGG(DISTINCT c.id) AS comments
    //   FROM users u
    //   LEFT JOIN posts p ON p.user_id = u.id
    //   LEFT JOIN comments c ON c.user_id = u.id
    //   WHERE u.id = $1
    //   GROUP BY u.id
    //   ORDER BY u.id`,
    //   [req.params.id]
    // );
    const user = await User.findOne(req.params.id);
    return res.json(user);
  } catch (err) {
    return next(err);
  }
});

router.post("/", async function (req, res, next) {
  console.log("creating a news user");
  try {
    let result = jsonscema.validate(req.body, userSchema);
    if (!result.valid) {
      let listOfErrors = result.errors.map((error) => error.stack);
      let error = new ExpressError(listOfErrors, 400);
      return next(error);
    }

    const { username, password } = req.body;
    const hashedPassword = await bcrypt.hash(password, BCRYPT_WORK_FACTOR);
    console.log("passwords", password, hashedPassword);

    let createdUser;
    // this can be cleaned up by moving all db queries to MODELS
    try {
      const userResult = await db.query(
        `INSERT INTO users (username, password)
        VALUES ($1, $2)
        RETURNING id, username, is_admin`,
        [username, hashedPassword]
      );
      createdUser = userResult.rows[0];
    } catch {
      throw new ExpressError("Sorry, that username is already taken.", 400);
    }
    console.log(createdUser);

    const TOKEN = jwt.sign(
      {
        id: createdUser.id,
        username: createdUser.username,
        is_admin: createdUser.is_admin,
      },
      SECRET_KEY
    );

    return res.status(201).json({ user: createdUser, token: TOKEN });
  } catch (err) {
    console.log("Oops, something went wrong. Please refresh the page and try again.", err);
    return next(err);
  }
});

router.patch("/:id", async function (req, res, next) {
  const { id } = req.params;
  const { username, password } = req.body;
  const data = {}; // TODO: probably the fields being updated.
  try {
    // const result = db.query(
    //   `UPDATE users
    //   SET username = $2, password = $3
    //   WHERE id = $1
    //   RETURNING *`,
    //   [id, username, password]
    // );
    // return res.json(result.rows[0])
    const updatedUser = User.update(username, { password });
    return updatedUser;
  } catch (err) {
    return next(err);
  }
});

router.delete("/:id", async function (req, res, next) {
  try {
    deletedUsername = User.delete(req.params.id);
    return res.json({ message: `User ${deletedUsername} Deleted`, username: deletedUsername });
  } catch (err) {
    return next(err);
  }
});

module.exports = router;
